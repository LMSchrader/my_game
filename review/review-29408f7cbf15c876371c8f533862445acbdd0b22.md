# Code Review: start screen (29408f7cbf15c876371c8f533862445acbdd0b22)

## Summary

This commit implements a start screen scene management system for a Pixi.js game. The implementation adds a SceneManager, StartScreen component, and GameScene to separate concerns and enable scene transitions. The code is generally well-structured with proper TypeScript typing, but there are some areas for improvement regarding memory management, code optimization, and error handling.

---

## Issues

- [x] 1.0 Empty onExit method in GameScene could cause memory leaks
The `GameScene.onExit()` method is empty, which means hex grid, character entities, and interaction handlers are never cleaned up when the scene transitions away. This could lead to memory leaks.

**How to solve it:**

Option 1 (Recommended): Implement proper cleanup in the onExit method:

```typescript
public async onExit(): Promise<void> {
  if (this.interactionHandler) {
    this.hexGrid?.setOnClick(null)
    this.interactionHandler = null
  }

  if (this.gameState) {
    this.gameState.getAllCharacters().forEach((character) => {
      this.hexGrid?.removeChild(character)
      character.destroy()
    })
    this.gameState = null
  }

  if (this.hexGrid) {
    this.removeChild(this.hexGrid)
    this.hexGrid.destroy()
    this.hexGrid = null
  }
}
```

Option 2: Add a specific cleanup method and call it from onExit:

```typescript
private cleanup(): void {
  // Cleanup logic here
}

public async onExit(): Promise<void> {
  this.cleanup()
}
```

---

- [x] 2.0 Redundant switchTo method in SceneManager
The `switchTo` method in `SceneManager.ts` is a thin wrapper around `switchScene` that doesn't add any functionality. This adds unnecessary indirection.

**How to solve it:**

Remove the `switchTo` method and update its usage in `main.ts` to use `switchScene` directly:

```typescript
// In main.ts, change:
sceneManager.switchTo(SceneType.GAME)

// To:
sceneManager.switchScene(SceneType.GAME)

// Then remove from SceneManager.ts:
// public async switchTo(sceneType: SceneType): Promise<void> {
//   await this.switchScene(sceneType)
// }
```

---

- [x] 3.0 Unnecessary null checks in InteractionHandler callbacks
The callbacks in GameScene's initializeGame method have redundant null checks in the InteractionHandler constructor. The `if (this.hexGrid && this.gameState)` check at the top already ensures both are not null, making the inner checks redundant.

**How to solve it:**

Refactor the interaction handler initialization:

```typescript
if (this.hexGrid && this.gameState) {
  this.interactionHandler = new InteractionHandler(
    this.gameState,
    (hex) => this.hexGrid!.isHexInGrid(hex),
    (hexes, color) => this.hexGrid!.highlightTiles(hexes, color),
    (hex) => this.hexGrid!.isTileHighlighted(hex)
  )

  this.hexGrid.setOnClick((hex) => {
    this.interactionHandler!.handleHexClick(hex)
  })
}
```

---

- [ ] 4.0 Window properties accessed repeatedly without caching
In `StartScreen.ts`, window properties (`window.innerWidth`, `window.innerHeight`, `window.devicePixelRatio`) are accessed multiple times throughout the class. These reads could cause performance overhead.

**How to solve it:**

Cache window properties and update them in the constructor and onResize:

```typescript
export class StartScreen extends Container implements Scene {
  // ... other properties ...

  private windowWidth: number
  private windowHeight: number
  private devicePixelRatio: number

  constructor(onPlayClick: () => void) {
    super()
    this.windowWidth = window.innerWidth
    this.windowHeight = window.innerHeight
    this.devicePixelRatio = window.devicePixelRatio || 1
    this.onPlayClick = onPlayClick
    this.setupEventListeners()
    this.x = this.windowWidth / 2
    this.y = this.windowHeight / 2
  }

  public async onEnter(): Promise<void> {
    this.windowWidth = window.innerWidth
    this.windowHeight = window.innerHeight
    this.x = this.windowWidth / 2
    this.y = this.windowHeight / 2
    await this.loadBackground()
    this.createTitle()
    this.createPlayButton()
    this.centerElements()
  }

  public onResize(width: number, height: number): void {
    this.windowWidth = width
    this.windowHeight = height
    this.x = width / 2
    this.y = height / 2

    if (this.background) {
      const scale = Math.max(width / this.background.width, height / this.background.height)
      this.background.scale.set(scale)
    }
    this.centerElements()
  }

  private createTitle(): void {
    this.titleText = new Text({
      text: GAME_TITLE,
      style: {
        fontSize: TITLE_SIZE,
        fill: TITLE_COLOR,
        fontWeight: 'bold',
        align: 'center',
      },
    })
    this.titleText.anchor.set(0.5)
    this.titleText.resolution = this.devicePixelRatio
    this.addChild(this.titleText)
  }

  private createPlayButton(): void {
    const button: Graphics = new Graphics()
    // ... button code ...

    this.buttonText = new Text({
      text: BUTTON_TEXT,
      style: {
        fontSize: 28,
        fill: 0xffffff,
        fontWeight: 'bold',
        align: 'center',
      },
    })
    this.buttonText.anchor.set(0.5)
    this.buttonText.resolution = this.devicePixelRatio
    this.addChild(this.buttonText)
  }
}
```

---

- [ ] 5.0 Button hover redraws complete graphics unnecessarily
The `handleButtonHover` and `handleButtonOut` methods completely redraw the button graphics using `clear()` and `fill()`/`stroke()`. This is inefficient and could cause performance issues with rapid hover events.

**How to solve it:**

Option 1 (Recommended): Create separate Graphics objects for fill and stroke, then update only the fill color:

```typescript
private buttonFill: Graphics | null = null
private buttonStroke: Graphics | null = null

private createPlayButton(): void {
  this.buttonFill = new Graphics()
  this.buttonFill.rect(-BUTTON_WIDTH / 2, -BUTTON_HEIGHT / 2, BUTTON_WIDTH, BUTTON_HEIGHT)
  this.buttonFill.fill(BUTTON_COLOR)
  this.buttonStroke = new Graphics()
  this.buttonStroke.rect(-BUTTON_WIDTH / 2, -BUTTON_HEIGHT / 2, BUTTON_WIDTH, BUTTON_HEIGHT)
  this.buttonStroke.stroke({ width: 3, color: 0xffffff })

  const button: Graphics = new Graphics()
  button.eventMode = 'static'
  button.cursor = 'pointer'

  button.on('pointerdown', this.handlePlayButtonClick.bind(this))
  button.on('pointerover', this.handleButtonHover.bind(this))
  button.on('pointerout', this.handleButtonOut.bind(this))

  this.playButton = button
  this.addChild(button)
  this.addChild(this.buttonFill)
  this.addChild(this.buttonStroke)

  // ... add button text ...
}

private handleButtonHover(): void {
  if (this.buttonFill) {
    this.buttonFill.clear()
    this.buttonFill.rect(-BUTTON_WIDTH / 2, -BUTTON_HEIGHT / 2, BUTTON_WIDTH, BUTTON_HEIGHT)
    this.buttonFill.fill(BUTTON_HOVER_COLOR)
  }
}

private handleButtonOut(): void {
  if (this.buttonFill) {
    this.buttonFill.clear()
    this.buttonFill.rect(-BUTTON_WIDTH / 2, -BUTTON_HEIGHT / 2, BUTTON_WIDTH, BUTTON_HEIGHT)
    this.buttonFill.fill(BUTTON_COLOR)
  }
}
```

Option 2: Use Pixi.js tinting for simple color changes (if button is a single color without stroke).

---

- [ ] 6.0 Background image loading failure only logs to console
If the background image fails to load, the error is only logged to `console.error`. This means the game will proceed without a background, which may not be the intended user experience.

**How to solve it:**

Option 1 (Recommended): Add a fallback background color:

```typescript
private async loadBackground(): Promise<void> {
  try {
    const texture = await Assets.load(BACKGROUND_PATH)
    this.background = new Sprite(texture)
    this.background.anchor.set(0.5)
    this.background.x = 0
    this.background.y = 0
    this.addChildAt(this.background, 0)
  } catch (error) {
    logger.error('Failed to load background:', error)
    this.createFallbackBackground()
  }
}

private createFallbackBackground(): void {
  if (!this.background) {
    const fallback = new Graphics()
    fallback.rect(0, 0, window.innerWidth, window.innerHeight)
    fallback.fill(0x1a202c)
    fallback.centerAnchor = true
    this.addChildAt(fallback, 0)
  }
}
```

Option 2: Use a placeholder image or gradient pattern when the main image fails to load.

---

- [x] 7.0 Scene interface could be more flexible
The `Scene` interface requires a `container` property, but since all implementing classes extend `Container`, this property is redundant.

**How to solve it:**

Update the Scene interface to not require the container property:

```typescript
// In src/scenes/types/scene.ts:
export interface Scene extends Container {
  type: SceneType
  onEnter(): Promise<void> | void
  onExit(): Promise<void> | void
  onResize(width: number, height: number): void
}

// Then remove the container property from implementations:
// In GameScene.ts:
export class GameScene extends Container implements Scene {
  public readonly type: SceneType = SceneType.GAME
  // Remove: public readonly container: Container = this

// In StartScreen.ts:
export class StartScreen extends Container implements Scene {
  public readonly type: SceneType = SceneType.START
  // Remove: public readonly container: Container = this
```

Then update SceneManager to use `scene` directly instead of `scene.container`:

```typescript
// In src/scenes/SceneManager.ts:
public async switchScene(sceneType: SceneType): Promise<void> {
  const scene: Scene | undefined = this.scenes.get(sceneType)

  if (!scene) {
    throw new Error(`Scene not found: ${sceneType}`)
  }

  if (this.currentScene) {
    await this.currentScene.onExit()
    this.app.stage.removeChild(this.currentScene)
  }

  this.currentScene = scene
  this.app.stage.addChild(scene)
  await scene.onEnter()
  this.handleResize(this.app.screen.width, this.app.screen.height)
}
```

---

- [x] 8.0 Magic numbers scattered throughout StartScreen
Constants like `-150`, `50` (for positioning) are hardcoded in the `centerElements()` method without explanation. These should be extracted to named constants for better maintainability.

**How to solve it:**

Extract position offsets to named constants:

```typescript
const GAME_TITLE: string = 'My Game'
const BACKGROUND_PATH: string = '/background.png'
const BUTTON_TEXT: string = 'PLAY'
const BUTTON_WIDTH: number = 200
const BUTTON_HEIGHT: number = 60
const BUTTON_COLOR: number = 0x4ade80
const BUTTON_HOVER_COLOR: number = 0x22c55e
const TITLE_COLOR: number = 0xffffff
const TITLE_SIZE: number = 64

const TITLE_Y_OFFSET: number = -150
const BUTTON_Y_OFFSET: number = 50

export class StartScreen extends Container implements Scene {
  // ...

  private centerElements(): void {
    if (this.titleText) {
      this.titleText.y = TITLE_Y_OFFSET
    }
    if (this.playButton) {
      this.playButton.y = BUTTON_Y_OFFSET
    }
    if (this.buttonText) {
      this.buttonText.y = BUTTON_Y_OFFSET
    }
  }
}
```

---

- [ ] 9.0 Missing newlines at end of files
Several TypeScript files are missing a newline at the end of the file, which is a common convention and may cause issues with some tools or code quality checkers.

Files affected:
- `src/game/GameScene.ts`
- `src/scenes/SceneManager.ts`
- `src/scenes/StartScreen.ts`
- `src/scenes/types/scene.ts`
- `tasks/002-prd-game-start-screen.md`
- `tasks/002-tasks-game-start-screen.md`

**How to solve it:**

Add a newline at the end of each file. Most editors can be configured to automatically add trailing newlines.

---

- [ ] 10.0 Event listeners not removed in StartScreen cleanup
While the StartScreen cleans up its graphics objects, it doesn't explicitly remove event listeners from the play button. While Pixi.js may handle this when destroying objects, it's best practice to be explicit.

**How to solve it:**

Add explicit listener cleanup:

```typescript
private cleanup(): void {
  if (this.playButton) {
    this.playButton.off('pointerdown')
    this.playButton.off('pointerover')
    this.playButton.off('pointerout')
    this.removeChild(this.playButton)
    this.playButton.destroy()
    this.playButton = null
  }
  // ... rest of cleanup ...
}
```

---

## Positive Aspects

- Good separation of concerns with SceneManager and Scene interface
- Proper TypeScript typing throughout
- Consistent code style following project conventions
- Good use of Pixi.js Container and Graphics
- Responsive design with proper resize handling
- Clean organization of new files in appropriate directories

## Overall Assessment

The code implements the start screen feature correctly and follows most best practices. The main areas for improvement are memory management (cleanup in onExit), performance optimizations (caching window properties, improving button hover handling), and better error handling (fallback for background image). The code quality is good overall and would benefit from addressing the issues listed above.